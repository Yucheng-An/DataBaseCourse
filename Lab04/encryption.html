<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Encryption/Decryption Performance</title>
</head>
<body>

<h2>Encrypt/Decrypt Sensor Data</h2>

<button onclick="generate1000Sensors()">Generate Sensors</button>
<button onclick="encryptData()">Encrypt</button>
<button onclick="decryptData()">Decrypt</button>

<p><strong>Encryption Time:</strong> <span id="encryptionTime"></span> ms</p>
<p><strong>Decryption Time:</strong> <span id="decryptionTime"></span> ms</p>

<p><strong>Encrypted Data:</strong> <span id="encryptedData"></span></p>
<p><strong>Decrypted Data:</strong> <span id="decryptedData"></span></p>

<script>
  let key = null;
  let iv = null;

  // Generate a cryptographic key
  async function generateKey() {
    key = await crypto.subtle.generateKey(
            { name: "AES-GCM", length: 256 },
            true,
            ["encrypt", "decrypt"]
    );
    iv = crypto.getRandomValues(new Uint8Array(12)); // Initialization vector
  }

  // Encrypt sensor data
  async function encryptSensorData(sensor) {
    if (!key) await generateKey();
    const encoder = new TextEncoder();
    const encodedData = encoder.encode(JSON.stringify(sensor));

    const encryptedArrayBuffer = await crypto.subtle.encrypt(
            { name: "AES-GCM", iv: iv },
            key,
            encodedData
    );

    return new Uint8Array(encryptedArrayBuffer).toString(); // Convert to string for storing
  }

  // Decrypt sensor data
  async function decryptSensorData(encryptedString) {
    if (!key) await generateKey();
    const encryptedDataArray = new Uint8Array(encryptedString.split(',').map(Number));
    const decryptedArrayBuffer = await crypto.subtle.decrypt(
            { name: "AES-GCM", iv: iv },
            key,
            encryptedDataArray
    );

    const decoder = new TextDecoder();
    return JSON.parse(decoder.decode(decryptedArrayBuffer));
  }

  function generate1000Sensors(){
    function getCurrentTimestamp() {
      return new Date().toISOString();
    }
    function generateRandomID() {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
      return Array.from({ length: 6 }, () => chars[Math.floor(Math.random() * chars.length)]).join('');
    }
    function generateRandomLocation() {
      const latitude = (Math.random() * 180 - 90).toFixed(6);
      const longitude = (Math.random() * 360 - 180).toFixed(6);
      return { latitude, longitude };
    }
    function generateRandomStatus() {
      const statuses = ['working', 'maintenance', 'error'];
      return statuses[Math.floor(Math.random() * statuses.length)];
    }
    async function generateObject() {
      const sensorData = {
        uuid: crypto.randomUUID(),
        sourceDB: "IndexedDB",
        createdTime: getCurrentTimestamp(),
        updatedTime: getCurrentTimestamp(),
        sensorID: generateRandomID(),
        sensorLocation: generateRandomLocation(),
        sensorStatus: generateRandomStatus()
      };
      // Encrypt before storing
      const encryptedSensor = await encryptSensorData(sensorData);
      return {
        encryptedSensor
      };
    }

    async function startGenerate() {
      let req = indexedDB.open("IndexDB", 1);
      req.onupgradeneeded = function(event) {
        let db = event.target.result;
        db.createObjectStore("Sensor", { keyPath: "id", autoIncrement: true });
      };
      req.onsuccess = function(event) {
        let db = event.target.result;
        let transactionSensor = db.transaction("Sensor", "readonly");
        let sensorObjectStore = transactionSensor.objectStore("Sensor");
        let countRequest = sensorObjectStore.count();
        countRequest.onsuccess = async function() {
          if (countRequest.result === 0) {
            let transaction = db.transaction("Sensor", "readwrite");
            let sensorObjectStoreWrite = transaction.objectStore("Sensor");
            let promises = [];
            for (let i = 0; i < 1000; i++) {
              const sensorObj = await generateObject();
              promises.push(sensorObjectStoreWrite.add(sensorObj));
            }
            transaction.oncomplete = function() {
              console.log('1000 Sensors random data have been added!!!');
            };
            transaction.onerror = function() {
              console.error('Error writing data to object store');
            };
          } else {
            console.log(`Database already contains ${countRequest.result} records, stop data generation.`);
          }
        };
        countRequest.onerror = function() {
          console.error('Error counting records in object store');
        };
      };
      req.onerror = function(event) {
        console.error('Error opening IndexedDB:', event.target.errorCode);
      };
    }
    startGenerate();
  }

  async function encryptData() {
    await generate1000Sensors();
  }

  async function decryptData() {
    let req = indexedDB.open("IndexDB", 1);
    req.onsuccess = function(event) {
      let db = event.target.result;
      let transaction = db.transaction("Sensor", "readonly");
      let sensorObjectStore = transaction.objectStore("Sensor");
      let getRequest = sensorObjectStore.getAll();

      getRequest.onsuccess = async function() {
        const decryptedData = await Promise.all(getRequest.result.map(async (item) => {
          return await decryptSensorData(item.encryptedSensor);
        }));

        console.log(decryptedData);
        document.getElementById('decryptedData').textContent = JSON.stringify(decryptedData, null, 2);
      };
    };
  }

</script>

</body>
</html>
